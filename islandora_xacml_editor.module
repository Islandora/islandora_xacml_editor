<?php
/**
 * @file
 * The main module file for the Islanora XACML Editor.
 */

/**
 * Implements hook_permission().
 */
function islandora_xacml_editor_permission() {
  return array(
    'administer islandora_xacml_editor' => array(
      'title' => 'Edit XACML Policies',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function islandora_xacml_editor_menu() {
  $items = array();
  $items['islandora/object/%islandora_object/manage/xacml'] = array(
    'title' => 'Object Policy',
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('islandora_xacml_editor_form', 2),
    'access callback' => 'islandora_xacml_editor_access',
    'access arguments' => array(2),
  );
  $items['admin/islandora/xacml/editor'] = array(
    'title' => 'Islandora XACML Editor',
    'description' => 'Settings for the Islandora XACML module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('islandora_xacml_editor_settings'),
    'access arguments' => array('administer islandora_xacml_editor'),
    'type' => MENU_LOCAL_TASK,
  );
  // We use %menu_tail to get around some of the issues that can arise with
  // users entering input for autocomplete. For example slashes would break.
  // Relevant Drupal thread: http://drupal.org/node/93854#comment-6164592.
  $items['islandora/xacml/dsidautocomplete/%/%menu_tail'] = array(
    'page callback' => 'islandora_xacml_editor_dsid_autocomplete',
    'page arguments' => array(3, 4),
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer islandora_xacml_editor'),
    'load arguments' => array('%map', '%index'),
  );
  $items['islandora/xacml/mimeautocomplete/%/%menu_tail'] = array(
    'page callback' => 'islandora_xacml_editor_mime_autocomplete',
    'page arguments' => array(3, 4),
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer islandora_xacml_editor'),
    'load arguments' => array('%map', '%index'),
  );
  return $items;
}

/**
 * Access callback function as to whether display the editor or not.
 *
 * @param AbstractObject $object
 *   A AbstractObject.
 *
 * @return bool
 *   TRUE if to show the tab, FALSE otherwise.
 */
function islandora_xacml_editor_access($object) {
  global $user;
  if (!user_access('administer islandora_xacml_editor') || !is_object($object)) {
    return FALSE;
  }

  if (isset($object['POLICY'])) {
    $xacml = new IslandoraXacml($object);
    return $xacml->managementRule->hasPermission($user->name, $user->roles);
  }
  else {
    return TRUE;
  }
}

/**
 * Admin settings form.
 */
function islandora_xacml_editor_settings() {
  drupal_add_css(drupal_get_path('module', 'islandora_xacml_editor') . '/css/islandora_xacml_editor.css');
  $form = array();

  $form['islandora_xacml_editor_show_dsidregex'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display the DSID regex textfield?'),
    '#default_value' => variable_get('islandora_xacml_editor_show_dsidregex', 1),
  );
  $form['islandora_xacml_editor_show_mimeregex'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display the MIME type regex textfield?'),
    '#default_value' => variable_get('islandora_xacml_editor_show_mimeregex', 1),
  );
  $form['islandora_xacml_editor_restrictions'] = array(
    '#type' => 'fieldset',
    '#title' => t('Restrictions for DSID and MIME type'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#description' => 'DSIDs and MIMEs that will not appear in the autocomplete fields or be allowed as filters.',
  );
  $form['islandora_xacml_editor_restrictions']['islandora_xacml_editor_restricted_dsids'] = array(
    '#type' => 'textarea',
    '#title' => t('DSID'),
    '#default_value' => variable_get('islandora_xacml_editor_restricted_dsids', ''),
  );
  $form['islandora_xacml_editor_restrictions']['islandora_xacml_editor_restricted_mimes'] = array(
    '#type' => 'textarea',
    '#title' => t('MIME type'),
    '#default_value' => variable_get('islandora_xacml_editor_restricted_mimes', ''),
  );
  $form['islandora_xacml_editor_defaults'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default users and roles'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#description' => t('The users and roles that will appear as the default selected unless there is a existing XACML policy attached to an object.'),
  );

  // Get the user list.
  $users = array();
  $result = db_query('SELECT u.uid, u.name FROM {users} u');
  foreach ($result as $user) {
    $user->uid == 0 ? $users['anonymous'] = 'anonymous' : $users[$user->name] = $user->name;
    if ($user->uid == 1) {
      $admin_user = $user->name;
      $form_state['islandora_xacml']['admin_user'] = $user->name;
    }
  }

  // Get role list.
  $roles = array();
  $result = db_query('SELECT r.rid, r.name FROM {role} r');
  foreach ($result as $role) {
    $role->rid == 0 ? $roles['anonymous'] = 'anonymous' : $roles[$role->name] = $role->name;
  }

  $form['islandora_xacml_editor_defaults']['islandora_xacml_editor_default_users'] = array(
    '#type' => 'select',
    '#title' => t('Users'),
    '#options' => $users,
    '#default_value' => variable_get('islandora_xacml_editor_default_users', 'admin'),
    '#multiple' => TRUE,
    '#size' => 10,
    '#prefix' => '<div class="islandora_xacml_selects">',
  );
  $form['islandora_xacml_editor_defaults']['islandora_xacml_editor_default_roles'] = array(
    '#type' => 'select',
    '#title' => t('Roles'),
    '#default_value' => variable_get('islandora_xacml_editor_default_roles', 'administrator'),
    '#options' => $roles,
    '#multiple' => TRUE,
    '#size' => 10,
    '#suffix' => '</div>',
  );
  return system_settings_form($form);
}

/**
 * The XACML editing form.
 */
function islandora_xacml_editor_form($form, &$form_state, $object) {
  drupal_add_css(drupal_get_path('module', 'islandora_xacml_editor') . '/css/islandora_xacml_editor.css');
  module_load_include('inc', 'islandora', 'includes/utilities');
  module_load_include('inc', 'islandora', 'includes/breadcrumb');

  drupal_set_title(t('Islandora XACML Editor'));

  if (!isset($form_state['islandora_xacml'])) {
    $form_state['islandora_xacml'] = array();
    $form_state['islandora_xacml']['object'] = $object;
  }

  if (!islandora_is_valid_pid($object->id)) {
    drupal_not_found();
    exit();
  }

  if (!$object) {
    drupal_not_found();
    exit();
  }

  drupal_set_breadcrumb(islandora_get_breadcrumbs($object));

  // Get the user list.
  $users = array();
  $result = db_query('SELECT u.uid, u.name FROM {users} u');
  foreach ($result as $user) {
    $user->uid == 0 ? $users['anonymous'] = 'anonymous' : $users[$user->name] = $user->name;
    if ($user->uid == 1) {
      $admin_user = $user->name;
      $form_state['islandora_xacml']['admin_user'] = $user->name;
    }
  }

  // Current user.
  $form_state['islandora_xacml']['current_user'] = $GLOBALS['user']->name;

  // Get role list.
  $roles = array();
  $result = db_query('SELECT r.rid, r.name FROM {role} r');
  foreach ($result as $role) {
    $role->rid == 0 ? $roles['anonymous'] = 'anonymous' : $roles[$role->name] = $role->name;
  }

  $new_xacml = FALSE;

  if (isset($object['POLICY'])) {
    // Some basic error handling.
    try {
      $xacml = new Xacml($object['POLICY']->content);
    }
    catch (XacmlException $e) {
      watchdog('islandora_xacml_editor', 'Exception in Islandora Xacml: @message', array('@message', $e->getMessage()), array(), WATCHDOG_ERROR);
      drupal_set_message($e->getMessage());
      drupal_set_message(t("Xacml Parser failed to parse @object_pid. It is likely this POLICY wasn't written by the islandora XACML editor, it will have to be modified by hand.",
                          array("@object_pid" => $object->id))
                        );
      drupal_not_found();
      exit();
    }
  }
  else {
    $new_xacml = TRUE;
    $xacml = new Xacml();
  }

  $form = array(
    '#tree' => TRUE,
  );

  $form['access_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable XACML Restrictions on Object Viewing'),
    '#default_value' => $xacml->viewingRule->isPopulated(),
  );

  $form['access'] = array(
    '#type' => 'fieldset',
    '#title' => t('Object Viewing'),
    '#tree' => TRUE,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#states' => array(
      'visible' => array(
        ':input[name="access_enabled"]' => array('checked' => TRUE),
      ),
    ),
  );

  $form['access']['users'] = array(
    '#type' => 'select',
    '#title' => t('Allowed Users'),
    '#default_value' => islandora_xacml_editor_retrieve_users($xacml, $new_xacml, 'viewing'),
    '#options' => $users,
    '#multiple' => TRUE,
    '#size' => 10,
    '#prefix' => '<div class="islandora_xacml_selects">',
  );

  $form['access']['roles'] = array(
    '#type' => 'select',
    '#title' => t('Allowed Roles'),
    '#options' => $roles,
    '#multiple' => TRUE,
    '#size' => 10,
    '#default_value' => islandora_xacml_editor_retrieve_roles($xacml, $new_xacml, 'viewing'),
    '#suffix' => '</div>',
  );

  // Grab original value used in comparisons.
  if (!isset($form_state['islandora_xacml']['access']['enabled'])) {
    $form_state['islandora_xacml']['access']['enabled'] = $form['access_enabled']['#default_value'];
  }

  $form['manage'] = array(
    '#weight' => -1,
    '#type' => 'fieldset',
    '#title' => t('Object Management'),
    '#description' => 'Select the Users and Roles that are allowed to manage this object. These users will also be able to view the object even if not explicitly allowed to in the object access section. WARNING: If you unselect yourself you will be locked out of the object.',
    '#collapsible' => FALSE,
  );

  $form['manage']['users'] = array(
    '#type' => 'select',
    '#title' => t('Users'),
    '#options' => $users,
    '#default_value' => islandora_xacml_editor_retrieve_users($xacml, $new_xacml, 'management'),
    '#multiple' => TRUE,
    '#size' => 10,
    '#prefix' => '<div class="islandora_xacml_selects">',
  );

  $form['manage']['roles'] = array(
    '#type' => 'select',
    '#title' => t('Roles'),
    '#default_value' => islandora_xacml_editor_retrieve_roles($xacml, $new_xacml, 'management'),
    '#options' => $roles,
    '#multiple' => TRUE,
    '#size' => 10,
    '#suffix' => '</div>',
  );

  $form['dsid_mime_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable XACML Restrictions on DSIDs and MIME types'),
    '#default_value' => $xacml->datastreamRule->isPopulated(),
  );

  $form['dsid_mime'] = array(
    '#type' => 'fieldset',
    '#title' => t('Datastreams and MIME types'),
    '#collapsible' => TRUE,
    '#tree' => TRUE,
    '#collapsed' => FALSE,
    '#states' => array(
      'visible' => array(
        ':input[name="dsid_mime_enabled"]' => array('checked' => TRUE),
      ),
    ),
  );

  // Grab the original value to be used in comparisons.
  if (!isset($form_state['islandora_xacml']['dsid_mime']['enabled'])) {
    $form_state['islandora_xacml']['dsid_mime']['enabled'] = $form['dsid_mime_enabled']['#default_value'];
  }

  // Call CModel oriented variants first.
  $query_choices = array();
  foreach (islandora_build_hook_list('islandora_xacml_editor_child_query', $object->models) as $hook) {
    $temp = module_invoke_all($hook, $object);
    if (!empty($temp)) {
      $query_choices = array_merge_recursive($query_choices, $temp);
    }
  }

  if (!empty($query_choices)) {
    // The "newchildren" option is applied automatically through ingest steps.
    $update_options = array('newchildren' => t('New children of this collection.'));
    foreach ($query_choices as $key => $query) {
      $form_state['islandora_xacml']['query_choices'][$key] = $query;
      $update_options[$key] = $query['description'];
    }
    $form['update_options'] = array(
      '#type' => 'select',
      '#title' => t('What items would you like to apply this policy to?'),
      '#default_value' => 'newchildren',
      '#options' => $update_options,
    );

    if (isset($form_state['islandora_xacml']['child_option'])) {
      $form['update_options']['#value'] = $form_state['islandora_xacml']['child_option'];
    }
  }

  $form['dsid_mime']['users'] = array(
    '#type' => 'select',
    '#title' => t('Users'),
    '#options' => $users,
    '#default_value' => islandora_xacml_editor_retrieve_users($xacml, $new_xacml, 'datastream'),
    '#multiple' => TRUE,
    '#size' => 10,
    '#prefix' => '<div class="islandora_xacml_selects">',
  );

  $form['dsid_mime']['roles'] = array(
    '#type' => 'select',
    '#title' => t('Roles'),
    '#default_value' => islandora_xacml_editor_retrieve_roles($xacml, $new_xacml, 'datastream'),
    '#options' => $roles,
    '#multiple' => TRUE,
    '#size' => 10,
    '#suffix' => '</div>',
  );

  // AJAX callbacks processing.
  if (isset($form_state['triggering_element'])) {
    // Add DSID.
    if ($form_state['triggering_element']['#name'] == 'dsid_add_button' || $form_state['triggering_element']['#name'] == 'dsid_add_textfield') {
      $object = $form_state['islandora_xacml']['object'];

      if (!isset($form_state['islandora_xacml']['add_dsid'])) {
        $form_state['islandora_xacml']['add_dsid'] = array();
      }

      $add_text = trim($form_state['input']['dsid_add_textfield']);

      if (!empty($add_text) && !ctype_space($add_text)) {
        // Check the additional dsids and the dsids from the XACML rules.
        if (isset($form_state['islandora_xacml']['add_dsid'])) {
          $added = array_search($add_text, $form_state['islandora_xacml']['add_dsid']);
        }

        if (isset($form_state['islandora_xacml']['selected_dsid'])) {
          $rules = array_search($add_text, $form_state['islandora_xacml']['selected_dsid']);
        }
        $restricted_dsids = variable_get('islandora_xacml_editor_restricted_dsids', '');
        $restricted_dsids = preg_split('/[\s,]+/', $restricted_dsids);

        if (!is_numeric($added) && $rules != $add_text && !in_array($add_text, $restricted_dsids)) {
          $form_state['islandora_xacml']['add_dsid'][] = $add_text;
        }
        elseif (in_array($add_text, $restricted_dsids)) {
          drupal_set_message(t('The DSID @dsid was not added as it is restricted from the admin settings page!',
            array(
              '@dsid' => $add_text,
            )
          ), 'warning');
        }
        else {
          drupal_set_message(t('The DSID @dsid was not added as it already exists as a filter!',
            array(
              '@dsid' => $add_text,
            )
          ), 'warning');
        }
      }
      else {
        drupal_set_message(t('No DSID value entered!'), 'error');
      }
    }
    // ADD DSID Regex.
    elseif ($form_state['triggering_element']['#name'] == 'dsid_regex_add_button' || $form_state['triggering_element']['#name'] == 'dsid_regex_add_textfield') {
      if (!isset($form_state['islandora_xacml']['dsid_regexs'])) {
        $form_state['islandora_xacml']['dsid_regexs'] = array();
      }
      $add_text = trim($form_state['input']['dsid_regex_add_textfield']);

      // Check the additional dsids and the dsids from the XACML rules.
      if (!empty($add_text) && !ctype_space($add_text)) {

        if (isset($form_state['islandora_xacml']['dsid_regexs'])) {
          $added = array_search($add_text, $form_state['islandora_xacml']['dsid_regexs']);
        }

        if (isset($form_state['islandora_xacml']['selected_dsid_regexs'])) {
          $rules = array_search($add_text, $form_state['islandora_xacml']['selected_dsid_regexs']);
        }

        if (!is_numeric($added) && $rules != $add_text) {
          $form_state['islandora_xacml']['dsid_regexs'][] = $add_text;
        }
        else {
          drupal_set_message(t('The DSID regex @regex was not added as it already exists as a filter!',
            array(
              '@regex' => $add_text,
            )
          ), 'warning');
        }
      }
      else {
        drupal_set_message(t('No DSID regex value entered!'), 'error');
      }
    }
    // Add MIME Regex.
    elseif ($form_state['triggering_element']['#name'] == 'mime_regex_add_button' || $form_state['triggering_element']['#name'] == 'mime_regex_add_textfield') {
      // Store and checks.
      if (!isset($form_state['islandora_xacml']['mime_regexs'])) {
        $form_state['islandora_xacml']['mime_regexs'] = array();
      }

      $add_text = trim($form_state['input']['mime_regex_add_textfield']);

      if (!empty($add_text) && !ctype_space($add_text)) {
        // Check the additional dsids and the dsids from the XACML rules.
        if (isset($form_state['islandora_xacml']['mime_regexs'])) {
          $added = array_search($add_text, $form_state['islandora_xacml']['mime_regexs']);
        }

        if (isset($form_state['islandora_xacml']['selected_mime_regexs'])) {
          $rules = array_search($add_text, $form_state['islandora_xacml']['selected_mime_regexs']);
        }

        if (!is_numeric($added) && $rules != $add_text) {
          $form_state['islandora_xacml']['mime_regexs'][] = $add_text;
        }
        else {
          drupal_set_message(t('The MIME type regex @regex was not added as it already exists as a filter!',
            array(
              '@regex' => $add_text,
            )
          ), 'warning');
        }
      }
      else {
        drupal_set_message(t('No MIME type regex value entered!'), 'error');
      }
    }
    // Add MIME type.
    elseif ($form_state['triggering_element']['#name'] == 'mime_add_button' || $form_state['triggering_element']['#name'] == 'mime_add_textfield') {
      if (!isset($form_state['islandora_xacml']['add_mime'])) {
        $form_state['islandora_xacml']['add_mime'] = array();
      }

      $add_text = $form_state['input']['mime_add_textfield'];
      if (!empty($add_text) && !ctype_space($add_text)) {
        if (isset($form_state['islandora_xacml']['add_mime'])) {
          $added = array_search($add_text, $form_state['islandora_xacml']['add_mime']);
        }

        if (isset($form_state['islandora_xacml']['selected_mime'])) {
          $rules = array_search($add_text, $form_state['islandora_xacml']['selected_mime']);
        }

        $restricted_mimes = variable_get('islandora_xacml_editor_restricted_mimes', '');
        $restricted_mimes = preg_split('/[\s,]+/', $restricted_mimes);

        if (!is_numeric($added) && $rules != $add_text && !in_array($add_text, $restricted_mimes)) {
          $form_state['islandora_xacml']['add_mime'][] = $add_text;
        }
        elseif (in_array($add_text, $restricted_mimes)) {
          drupal_set_message(t('The MIME type @mime was not added as it is restricted from the admin settings page!',
            array(
              '@mime' => $add_text,
            )
          ), 'warning');
        }
        else {
          drupal_set_message(t('The MIME type @mime was not added as it already exists as a filter!',
            array(
              '@mime' => $add_text,
            )
          ), 'warning');
        }
      }
      else {
        drupal_set_message(t('No MIME type value entered!'), 'error');
      }
    }
    elseif ($form_state['triggering_element']['#name'] == 'islandora_xacml_editor_remove_all') {
      $remove_count = 0;

      foreach ($form_state['islandora_xacml']['rows'] as $key => $value) {
        $type = drupal_strtolower($value['Type']);
        $filter = $value['Filter'];

        $remove_key = array_search($filter, $form_state['islandora_xacml']['dsid_mime'][$type]);

        if ($type == 'dsid') {
          $form_state['islandora_xacml']['remove_dsid'][] = $filter;
        }
        elseif ($type == 'mime type') {
          $form_state['islandora_xacml']['remove_mime'][] = $filter;
        }
        elseif ($type == 'mime type regex') {
          $form_state['islandora_xacml']['remove_mime_regex'][] = $filter;
        }
        elseif ($type == 'dsid regex') {
          $form_state['islandora_xacml']['remove_dsid_regex'][] = $filter;
        }
        $remove_count++;
      }

      $remove_output = format_plural($remove_count, '!filter_count applied filter was removed.',
              '!filter_count applied filters were removed.', array('!filter_count' => $remove_count));
      drupal_set_message($remove_output);
    }
    elseif ($form_state['triggering_element']['#name'] == 'islandora_xacml_editor_remove_selected') {
      $remove_row = array();
      foreach ($form_state['values']['dsid_mime']['rules']['table'] as $checkbox => $value) {
        if ($value !== 0) {
          $remove_row[] = $checkbox;
        }
      }
      if (count($remove_row) > 0) {
        $remove_count = 0;

        foreach ($remove_row as $row) {
          $remove_vals = explode('---', $row);
          $type = $remove_vals[0];
          $filter = $remove_vals[1];

          $remove_key = array_search($filter, $form_state['islandora_xacml']['dsid_mime'][$type]);

          if ($type == 'dsid') {
            $form_state['islandora_xacml']['remove_dsid'][] = $filter;
          }
          elseif ($type == 'mime') {
            $form_state['islandora_xacml']['remove_mime'][] = $filter;
          }
          elseif ($type == 'mime_regexs') {
            $form_state['islandora_xacml']['remove_mime_regex'][] = $filter;
          }
          elseif ($type == 'dsid_regexs') {
            $form_state['islandora_xacml']['remove_dsid_regex'][] = $filter;
          }
          $remove_count++;
        }
        $remove_output = format_plural($remove_count, '!filter_count applied filter was removed.',
              '!filter_count applied filters were removed.', array('!filter_count' => $remove_count));
        drupal_set_message($remove_output);
      }
      else {
        drupal_set_message(t('Please select the filters you wish to remove.'), 'error');
      }
    }
  }

  // Grab these values to handle removal.
  $temp_mime = $xacml->datastreamRule->getMimetypes();
  $temp_dsid = $xacml->datastreamRule->getDsids();
  $temp_mime_regexs = $xacml->datastreamRule->getMimetypeRegexs();
  $temp_dsid_regexs = $xacml->datastreamRule->getDsidRegexs();

  if (isset($form_state['islandora_xacml']['remove_dsid'])) {
    foreach ($form_state['islandora_xacml']['remove_dsid'] as $value) {
      $key = array_search($value, $temp_dsid);

      // If the value is not one of our 'hidden DSIDs'
      if (is_numeric($key)) {
        $xacml->datastreamRule->removeDsid($temp_dsid[$key]);
        $form_state['islandora_xacml']['hidden_dsids'][] = $value;
      }

      if (isset($form_state['islandora_xacml']['add_dsid'])) {
        $search = array_search($value, $form_state['islandora_xacml']['add_dsid']);

        if (is_numeric($search)) {
          unset($form_state['islandora_xacml']['add_dsid'][$search]);
        }
      }
    }
    unset($form_state['islandora_xacml']['remove_dsid']);
  }

  if (isset($form_state['islandora_xacml']['remove_mime'])) {
    foreach ($form_state['islandora_xacml']['remove_mime'] as $value) {
      $key = array_search($value, $temp_mime);

      // If the value is not one of our 'hidden mimes'
      if (is_numeric($key)) {
        $xacml->datastreamRule->removeMimetype($temp_mime[$key]);
        $form_state['islandora_xacml']['hidden_mimes'][] = $value;
      }

      if (isset($form_state['islandora_xacml']['add_mime'])) {
        $search = array_search($value, $form_state['islandora_xacml']['add_mime']);

        if (is_numeric($search)) {
          unset($form_state['islandora_xacml']['add_mime'][$search]);
        }
      }
    }
    unset($form_state['islandora_xacml']['remove_mime']);
  }

  if (isset($form_state['islandora_xacml']['remove_mime_regex'])) {
    foreach ($form_state['islandora_xacml']['remove_mime_regex'] as $value) {
      $key = array_search($value, $temp_mime_regexs);

      // If the value is not one of our 'hidden mime regexs'
      if (is_numeric($key)) {
        $xacml->datastreamRule->removeMimetypeRegex($temp_mime_regexs[$key]);
        $form_state['islandora_xacml']['hidden_mime_regexs'][] = $value;
      }

      if (isset($form_state['islandora_xacml']['mime_regexs'])) {
        $search = array_search($value, $form_state['islandora_xacml']['mime_regexs']);

        if (is_numeric($search)) {
          unset($form_state['islandora_xacml']['mime_regexs'][$search]);
        }
      }
    }
    unset($form_state['islandora_xacml']['remove_mime_regex']);
  }

  if (isset($form_state['islandora_xacml']['remove_dsid_regex'])) {
    foreach ($form_state['islandora_xacml']['remove_dsid_regex'] as $value) {
      $key = array_search($value, $temp_dsid_regexs);

      // If the value is not one of our 'hidden mimes'
      if (is_numeric($key)) {
        $xacml->datastreamRule->removeDsidRegex($temp_dsid_regexs[$key]);
        $form_state['islandora_xacml']['hidden_dsid_regexs'][] = $value;
      }

      if (isset($form_state['islandora_xacml']['dsid_regexs'])) {
        $search = array_search($value, $form_state['islandora_xacml']['dsid_regexs']);

        if (is_numeric($search)) {
          unset($form_state['islandora_xacml']['dsid_regexs'][$search]);
        }
      }
    }
    unset($form_state['islandora_xacml']['remove_dsid_regex']);
  }

  // If we are carrying values from the original rule that need to be removed
  // remove them.
  if (isset($form_state['islandora_xacml']['hidden_mimes'])) {
    foreach ($form_state['islandora_xacml']['hidden_mimes'] as $key => $value) {
      $xacml->datastreamRule->removeMimetype($value);
    }
  }

  if (isset($form_state['islandora_xacml']['hidden_dsids'])) {
    foreach ($form_state['islandora_xacml']['hidden_dsids'] as $key => $value) {
      $xacml->datastreamRule->removeDsid($value);
    }
  }

  if (isset($form_state['islandora_xacml']['hidden_mime_regexs'])) {
    foreach ($form_state['islandora_xacml']['hidden_mime_regexs'] as $key => $value) {
      $xacml->datastreamRule->removeMimetypeRegex($value);
    }
  }

  if (isset($form_state['islandora_xacml']['hidden_dsid_regexs'])) {
    foreach ($form_state['islandora_xacml']['hidden_dsid_regexs'] as $key => $value) {
      $xacml->datastreamRule->removeDsidRegex($value);
    }
  }

  // Grab the updated values to handle addition of rules.
  $temp_mime = $xacml->datastreamRule->getMimetypes();
  $temp_dsid = $xacml->datastreamRule->getDsids();
  $temp_mime_regexs = $xacml->datastreamRule->getMimetypeRegexs();
  $temp_dsid_regexs = $xacml->datastreamRule->getDsidRegexs();

  // Add any values we are carrying in the form storage to the datastream rules.
  if (isset($form_state['islandora_xacml']['add_dsid'])) {
    foreach ($form_state['islandora_xacml']['add_dsid'] as $key => $value) {
      $search = array_search($value, $temp_dsid);

      if (!is_numeric($search)) {
        $xacml->datastreamRule->addDsid($value);

        if (isset($form_state['islandora_xacml']['hidden_sids'])) {
          $remove_dsid = array_search($value, $form_state['islandora_xacml']['hidden_dsids']);

          if (is_numeric($remove_dsid)) {
            unset($form_state['islandora_xacml']['hidesids'][$remove_dsid]);
          }
        }
      }
    }
  }

  if (isset($form_state['islandora_xacml']['add_mime'])) {
    foreach ($form_state['islandora_xacml']['add_mime'] as $key => $value) {
      $search = array_search($value, $temp_mime);

      if (!is_numeric($search)) {
        $xacml->datastreamRule->addMimetype($value);

        if (isset($form_state['islandora_xacml']['hidden_mimes'])) {
          $remove_mime = array_search($value, $form_state['islandora_xacml']['hidden_mimes']);

          if (is_numeric($remove_mime)) {
            unset($form_state['islandora_xacml']['hidden_mimes'][$remove_mime]);
          }
        }
      }
    }
  }

  if (isset($form_state['islandora_xacml']['dsid_regexs'])) {
    foreach ($form_state['islandora_xacml']['dsid_regexs'] as $key => $value) {
      $search = array_search($value, $temp_dsid_regexs);

      if (!is_numeric($search)) {
        $xacml->datastreamRule->addDsidRegex($value);

        if (isset($form_state['islandora_xacml']['hidden_dsid_regexs'])) {
          $remove_dsid = array_search($value, $form_state['islandora_xacml']['hidden_dsid_regexs']);

          if (is_numeric($remove_dsid)) {
            unset($form_state['islandora_xacml']['hidden_dsid_regexs'][$remove_dsid]);
          }
        }
      }
    }
  }

  if (isset($form_state['islandora_xacml']['mime_regexs'])) {
    foreach ($form_state['islandora_xacml']['mime_regexs'] as $key => $value) {
      $search = array_search($value, $temp_mime_regexs);

      if (!is_numeric($search)) {
        $xacml->datastreamRule->addMimetypeRegex($value);

        if (isset($form_state['islandora_xacml']['hidden_mime_regexs'])) {
          $remove_mime = array_search($value, $form_state['islandora_xacml']['hidden_mime_regexs']);

          if (is_numeric($remove_mime)) {
            unset($form_state['islandora_xacml']['hidden_mime_regexs'][$remove_mime]);
          }
        }
      }
    }
  }

  // Grab the values one last time for storage and use in constructing the
  // rules table.
  $selected_mime = $xacml->datastreamRule->getMimetypes();
  $selected_dsid = $xacml->datastreamRule->getDsids();
  $selected_mime_regexs = $xacml->datastreamRule->getMimetypeRegexs();
  $selected_dsid_regexs = $xacml->datastreamRule->getDsidRegexs();

  // We store these values for use in the AJAX callbacks.
  $form_state['islandora_xacml']['dsid_mime']['dsid'] = $selected_dsid;
  $form_state['islandora_xacml']['dsid_mime']['mime'] = $selected_mime;
  $form_state['islandora_xacml']['dsid_mime']['dsid_regexs'] = $selected_dsid_regexs;
  $form_state['islandora_xacml']['dsid_mime']['mime_regexs'] = $selected_mime_regexs;

  if (count($selected_mime) > 0) {
    $form_state['islandora_xacml']['selected_mime'] = array_combine($selected_mime, $selected_mime);
  }
  else {
    unset($form_state['islandora_xacml']['selected_mime']);
  }

  if (count($selected_dsid) > 0) {
    $form_state['islandora_xacml']['selected_dsid'] = array_combine($selected_dsid, $selected_dsid);
  }
  else {
    unset($form_state['islandora_xacml']['selected_dsid']);
  }

  if (count($selected_mime_regexs) > 0) {
    $form_state['islandora_xacml']['selected_mime_regexs'] = array_combine($selected_mime_regexs, $selected_mime_regexs);
  }
  else {
    unset($form_state['islandora_xacml']['selected_mime_regexs']);
  }

  if (count($selected_dsid_regexs) > 0) {
    $form_state['islandora_xacml']['selected_dsid_regexs'] = array_combine($selected_dsid_regexs, $selected_dsid_regexs);
  }
  else {
    unset($form_state['islandora_xacml']['selected_dsid_regexs']);
  }

  $rows = array();
  // Name the rows with a --- convention such that we can easily parse
  // for the selected row to remove down the road.
  if (!empty($selected_mime)) {
    foreach ($selected_mime as $mime) {
      $rows['mime---' . trim($mime)] = array(
        'Filter' => trim($mime),
        'Type' => 'MIME Type',
      );
    }
  }

  if (!empty($selected_mime_regexs)) {
    foreach ($selected_mime_regexs as $mime_regex) {
      $rows['mime_regexs---' . trim($mime_regex)] = array(
        'Filter' => trim($mime_regex),
        'Type' => 'MIME Type Regex',
      );
    }
  }

  if (!empty($selected_dsid)) {
    foreach ($selected_dsid as $dsid) {
      $rows['dsid---' . trim($dsid)] = array(
        'Filter' => trim($dsid),
        'Type' => 'DSID',
      );
    }
  }

  if (!empty($selected_dsid_regexs)) {
    foreach ($selected_dsid_regexs as $dsid_regex) {
      $rows['dsid_regexs---' . $dsid_regex] = array(
        'Filter' => trim($dsid_regex),
        'Type' => 'DSID Regex',
      );
    }
  }
  $form_state['islandora_xacml']['rows'] = $rows;
  $form['dsid_mime']['rules'] = array(
    '#prefix' => '<div id="islandora_xacml_dsid_mime">',
    '#suffix' => '</div>',
  );

  $form['dsid_mime']['rules']['label'] = array(
    '#type' => 'item',
    '#markup' => (count($rows) > 0) ? '<strong>Applied Rules:</strong>' : '<strong>No rules applied!</strong>',
  );
  if (count($rows) > 0) {
    $form['dsid_mime']['rules']['table'] = islandora_xacml_editor_form_table($rows);

    $form['dsid_mime']['rules']['remove_selected'] = array(
      '#type' => 'button',
      '#value' => t('Remove selected'),
      '#name' => 'islandora_xacml_editor_remove_selected',
      '#ajax' => array(
        'event' => 'click',
        'callback' => 'islandora_xacml_editor_remove_selected',
        'wrapper' => 'islandora_xacml_dsid_mime',
        'method' => 'replace',
      ),
    );
    $form['dsid_mime']['rules']['remove_all'] = array(
      '#type' => 'button',
      '#value' => t('Remove all'),
      '#name' => 'islandora_xacml_editor_remove_all',
      '#ajax' => array(
        'event' => 'click',
        'callback' => 'islandora_xacml_editor_remove_all',
        'wrapper' => 'islandora_xacml_dsid_mime',
      ),
    );
  }

  $form['dsid_mime']['new_dsid'] = array(
    '#type' => 'textfield',
    '#title' => t('DSID'),
    '#autocomplete_path' => 'islandora/xacml/dsidautocomplete/' . $object->id,
    '#size' => 35,
    '#description' => t('Type "*" to list all DSIDs.'),
    '#prefix' => '<div class="islandora_xacml_block_description">',
    '#name' => 'dsid_add_textfield',
    '#ajax' => array(
      'event' => 'error',
      'callback' => 'islandora_xacml_editor_add_dsid_js',
      'wrapper' => 'islandora_xacml_dsid_mime',
      'keypress' => TRUE,
    ),
  );
  $form['dsid_mime']['new_dsid_add'] = array(
    '#name' => 'dsid_add_button',
    '#type' => 'button',
    '#value' => t('Add'),
    '#suffix' => '</div>',
    '#ajax' => array(
      'event' => 'click',
      'callback' => 'islandora_xacml_editor_add_dsid_js',
      'wrapper' => 'islandora_xacml_dsid_mime',
    ),
  );

  if (variable_get('islandora_xacml_editor_show_dsidregex', 1)) {
    $form['dsid_mime']['dsid_regex'] = array(
      '#type' => 'textfield',
      '#title' => t('DSID Regex'),
      '#size' => 35,
      '#prefix' => '<div class="islandora_xacml_block">',
      '#name' => 'dsid_regex_add_textfield',
      '#ajax' => array(
        'event' => 'error',
        'callback' => 'islandora_xacml_editor_add_dsid_regex_js',
        'wrapper' => 'islandora_xacml_dsid_mime',
        'keypress' => TRUE,
      ),
    );
    $form['dsid_mime']['dsid_regex_add'] = array(
      '#name' => 'dsid_regex_add_button',
      '#type' => 'button',
      '#value' => t('Add'),
      '#suffix' => '</div>',
      '#ajax' => array(
        'event' => 'click',
        'callback' => 'islandora_xacml_editor_add_dsid_regex_js',
        'wrapper' => 'islandora_xacml_dsid_mime',
      ),
    );
  }
  $form['dsid_mime']['new_mime'] = array(
    '#type' => 'textfield',
    '#title' => t('MIME type'),
    '#autocomplete_path' => 'islandora/xacml/mimeautocomplete/' . $object->id,
    '#size' => 35,
    '#description' => t('Type "*" to list all MIME types.'),
    '#prefix' => '<div class="islandora_xacml_block_description">',
    '#name' => 'mime_add_textfield',
    '#ajax' => array(
      'event' => 'error',
      'callback' => 'islandora_xacml_editor_add_mime_js',
      'wrapper' => 'islandora_xacml_dsid_mime',
      'keypress' => TRUE,
    ),
  );
  $form['dsid_mime']['new_mime_add'] = array(
    '#name' => 'mime_add_button',
    '#type' => 'button',
    '#value' => t('Add'),
    '#suffix' => '</div>',
    '#ajax' => array(
      'event' => 'click',
      'callback' => 'islandora_xacml_editor_add_mime_js',
      'wrapper' => 'islandora_xacml_dsid_mime',
    ),
  );

  if (variable_get('islandora_xacml_editor_show_mimeregex', 1)) {
    $form['dsid_mime']['mime_regex'] = array(
      '#type' => 'textfield',
      '#title' => t('MIME type Regex'),
      '#size' => 35,
      '#prefix' => '<div class="islandora_xacml_block">',
      '#name' => 'mime_regex_add_textfield',
      '#ajax' => array(
        'event' => 'error',
        'callback' => 'islandora_xacml_editor_add_mime_regex_js',
        'wrapper' => 'islandora_xacml_dsid_mime',
        'method' => 'replace',
        'keypress' => TRUE,
      ),
    );
    $form['dsid_mime']['mime_regex_add'] = array(
      '#name' => 'mime_regex_add_button',
      '#type' => 'button',
      '#value' => t('Add'),
      '#suffix' => '</div>',
      '#ajax' => array(
        'event' => 'click',
        'callback' => 'islandora_xacml_editor_add_mime_regex_js',
        'wrapper' => 'islandora_xacml_dsid_mime',
        'method' => 'replace',
      ),
    );
  }
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Set Permissions'),
  );

  return $form;
}

/**
 * Retrieves the users selected in each 'Users' portion for datastream rules.
 *
 * @param Xacml $xacml
 *   The XACML object.
 *
 * @param bool $new_xacml
 *   Whether there already exists an XACML policy or not.
 *
 * @param string $rule
 *   The rule which we are checking against.
 *
 * @return array
 *   An array of users that are selected for the specific rule.
 */
function islandora_xacml_editor_retrieve_users($xacml, $new_xacml, $rule) {
  if ($new_xacml == FALSE) {
    if ($rule == 'viewing' && $xacml->viewingRule->isPopulated()) {
      return $xacml->viewingRule->getUsers();
    }
    elseif ($rule == 'datastream' && $xacml->datastreamRule->isPopulated()) {
      return $xacml->datastreamRule->getUsers();
    }
    elseif ($rule == 'management' && $xacml->managementRule->isPopulated()) {
      return $xacml->managementRule->getUsers();
    }
    else {
      return variable_get('islandora_xacml_editor_default_users', 'admin');
    }
  }
  else {
    return variable_get('islandora_xacml_editor_default_users', 'admin');
  }
}

/**
 * Retrieves the roles selected in each 'Roles' portion for datastream rules.
 *
 * @param Xacml $xacml
 *   The XACML object.
 *
 * @param bool $new_xacml
 *   Whether there already exists an XACML policy or not.
 *
 * @param string $rule
 *   The rule which we are checking against.
 *
 * @return array
 *   An array of roles that are selected for the specific rule.
 */
function islandora_xacml_editor_retrieve_roles($xacml, $new_xacml, $rule) {
  if ($new_xacml == FALSE) {
    if ($rule == 'viewing' && $xacml->viewingRule->isPopulated()) {
      return $xacml->viewingRule->getRoles();
    }
    elseif ($rule == 'datastream' && $xacml->datastreamRule->isPopulated()) {
      return $xacml->datastreamRule->getRoles();
    }
    elseif ($rule == 'management' && $xacml->managementRule->isPopulated()) {
      return $xacml->managementRule->getRoles();
    }
    else {
      return variable_get('islandora_xacml_editor_default_roles', 'administrator');
    }
  }
  else {
    return variable_get('islandora_xacml_editor_default_roles', 'administrator');
  }
}

/**
 * Constructs the tableselect used in slandora_xacml_editor_form().
 *
 * @param array $passed_rows
 *   The rows containing the data that need to be rendered.
 *
 * @return array
 *   An array that represents the tableselect to be rendered.
 */
function islandora_xacml_editor_form_table(array $passed_rows) {
  $headers = array(
    'filter' => t('Filter'),
    'type' => t('Type'),
  );

  $rows = array();
  foreach ($passed_rows as $key => $value) {
    $filter = $value['Filter'];
    $type = $value['Type'];
    $rows[$key] = array(
      'filter' => $filter,
      'type' => $type,
    );
  }

  $table = array(
    '#type' => 'tableselect',
    '#header' => $headers,
    '#options' => $rows,
  );
  return $table;
}

/**
 * Implements hook_validate().
 */
function islandora_xacml_editor_form_validate(&$form, &$form_state) {
  drupal_add_css(drupal_get_path('module', 'islandora_xacml_editor') . '/css/islandora_xacml_editor.css');
  $button_trig = array(
    'dsid_add_button',
    'mime_add_button',
    'dsid_regex_add_button',
    'mime_regex_add_button',
  );
  // Test if the user is locking themselves or the admin out of the object.
  $admin_user = $form_state['islandora_xacml']['admin_user'];
  $current_user = $form_state['islandora_xacml']['current_user'];

  // Management functions.
  if (!array_key_exists($admin_user, $form_state['values']['manage']['users']) ||
      !array_key_exists($current_user, $form_state['values']['manage']['users'])) {
    if ($admin_user == $current_user) {
      form_set_error('manage][users', "Please make sure that $admin_user is selected in the manage
        section to prevent locking yourself out of the object.");
    }
    else {
      form_set_error('manage][users', "Please make sure that $admin_user and $current_user are selected in the manage
        section to prevent locking yourself and the admin user out of the object.");
    }
  }

  if ($form_state['values']['dsid_mime_enabled']) {
    if (!array_key_exists($current_user, $form_state['values']['dsid_mime']['users'])) {
      if ($admin_user == $current_user) {
        form_set_error('dsid_mime][users', "Please make sure that $admin_user is selected in the manage
        section to prevent locking yourself out of the object.");
      }
      else {
        form_set_error('dsid_mime][users', "Please make sure that $admin_user and $current_user are selected in the manage
        section to prevent locking yourself and the admin user out of the object.");
      }
    }

    if (count($form_state['islandora_xacml']['rows']) == 0 && (!in_array($form_state['triggering_element']['#name'], $button_trig))) {
      form_set_error('dsid_mime][rules', "There are no filters applied in the datastream and MIME type section.");
    }
  }
}

/**
 * The submit function where all the XACML magic happens. Abracadabra.
 */
function islandora_xacml_editor_form_submit(&$form, &$form_state) {
  $object = $form_state['islandora_xacml']['object'];
  $pid = $object->id;
  $xacml = new IslandoraXacml($object);

  // Check datastreams and mime.
  $values = $form_state['values']['dsid_mime'];

  if ($form_state['values']['dsid_mime_enabled']) {
    $xacml->datastreamRule->clear();

    if (array_key_exists('selected_mime', $form_state['islandora_xacml'])) {
      $xacml->datastreamRule->addMimetype($form_state['islandora_xacml']['selected_mime']);
    }

    if (array_key_exists('selected_dsid', $form_state['islandora_xacml'])) {
      $xacml->datastreamRule->addDsid($form_state['islandora_xacml']['selected_dsid']);
    }

    if (array_key_exists('selected_mime_regexs', $form_state['islandora_xacml'])) {
      $xacml->datastreamRule->addMimetypeRegex($form_state['islandora_xacml']['selected_mime_regexs']);
    }

    if (array_key_exists('selected_dsid_regexs', $form_state['islandora_xacml'])) {
      $xacml->datastreamRule->addDsidRegex($form_state['islandora_xacml']['selected_dsid_regexs']);
    }

    $xacml->datastreamRule->addUser($values['users']);
    $xacml->datastreamRule->addRole($values['roles']);
  }
  // User selects to disable the datastream rule when it was previously enabled.
  elseif ($form_state['values']['dsid_mime_enabled'] != $form_state['islandora_xacml']['dsid_mime']['enabled']) {
    $xacml->datastreamRule->clear();
  }
  // Check admin (always have this rule).
  $values = $form_state['values']['manage'];
  $xacml->managementRule->clear();
  $xacml->managementRule->addUser($values['users']);
  $xacml->managementRule->addRole($values['roles']);

  // Check access.
  $values = $form_state['values']['access'];
  if ($form_state['values']['access_enabled']) {
    $xacml->viewingRule->clear();
    $xacml->viewingRule->addUser($values['users']);
    $xacml->viewingRule->addRole($values['roles']);
  }
  // User selects to disable the access rule when it was previously enabled.
  elseif ($form_state['values']['access_enabled'] != $form_state['islandora_xacml']['access']['enabled']) {
    $xacml->viewingRule->clear();
  }

  $xacml->writeBackToFedora();

  if (isset($form_state['islandora_xacml']['query_choices'])) {
    if ($form_state['values']['update_options'] != 'newchildren') {
      $option = $form_state['values']['update_options'];
      $query_array = $form_state['islandora_xacml']['query_choices'][$option];
      $xml = $xacml->getXmlString();
      $batch = array(
        'title' => t('Updating Policies'),
        'progress_message' => t('Please wait if many objects are being updated this could take a few minutes.'),
        'operations' => array(
          array(
            'islandora_xacml_editor_batch_function',
            array($xml, $pid, $query_array),
          ),
        ),
        'finished' => 'islandora_xacml_editor_batch_finished',
      );
      batch_set($batch);
    }
    else {
      unset($form_state['islandora_xacml']);
      $form_state['redirect'] = array('islandora/object/' . $pid);
    }
  }
  else {
    unset($form_state['islandora_xacml']);
    $form_state['redirect'] = array('islandora/object/' . $pid);
  }
}

/**
 * Implements hook_islandora_datastream_purged().
 */
function islandora_xacml_editor_islandora_datastream_purged(AbstractObject $object, $dsid) {
  $viewable_by_user = 'isViewableByUser';
  $viewable_by_role = 'isViewableByRole';
  // The XACML POLICY is removed.
  if ($dsid === 'POLICY') {
    $object->relationships->remove(ISLANDORA_RELS_EXT_URI, $viewable_by_user);
    $object->relationships->remove(ISLANDORA_RELS_EXT_URI, $viewable_by_role);
    foreach ($object as $dsid => $value) {
      $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_user);
      $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_role);
    }
  }
  else {
    // An individual datastream is removed.
    if (isset($object['POLICY'])) {
      $xacml = new IslandoraXacml($object);
      $ds_rule = $xacml->datastreamRule->getRuleArray();
      if (array_search($dsid, $ds_rule['dsids']) !== FALSE) {
        if (count($ds_rule['users']) > 0) {
          $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_user);
        }
        if (count($ds_rule['roles']) > 0) {
          $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_role);
        }
      }
    }
  }
}

/**
 * Implements hook_islandora_datastream_ingested().
 */
function islandora_xacml_editor_islandora_datastream_ingested(AbstractObject $object, AbstractDatastream $datastream) {
  if (isset($object['POLICY'])) {
    $xacml = new IslandoraXacml($object);
    $ds_rule = $xacml->datastreamRule->getRuleArray();
    if (array_search($datastream->id, $ds_rule['dsids']) !== FALSE) {
      $viewable_by_user = 'isViewableByUser';
      $viewable_by_role = 'isViewableByRole';
      if (count($ds_rule['users']) > 0) {
        foreach ($ds_rule['users'] as $user) {
          // The XACML API adds fedoraAdmin to the list of users as to prevent
          // an object from being completely locked out. As this role is a
          // Fedora role and has no interaction with Drupal we won't add it for
          // cleanliness sake.
          if ($user !== 'fedoraAdmin') {
            $object[$datastream->id]->relationships->add(ISLANDORA_RELS_INT_URI, $viewable_by_user, $user, TRUE);
          }
        }
      }
      if (count($ds_rule['roles']) > 0) {
        foreach ($ds_rule['roles'] as $role) {
          $object[$datastream->id]->relationships->add(ISLANDORA_RELS_INT_URI, $viewable_by_role, $role, TRUE);
        }
      }
    }
  }
}

/**
 * Implemenets hook_islandora_xacml_editor_child_query().
 */
function islandora_xacml_editor_islandora_collectionCModel_islandora_xacml_editor_child_query($object) {
  $collection_query = 'select $object from <#ri> where
        ($object <fedora-rels-ext:isMemberOfCollection> <info:fedora/' . $object->id . '> or
        $object <fedora-rels-ext:isMemberOf> <info:fedora/' . $object->id . '>)
        and $object <fedora-model:state> <info:fedora/fedora-system:def/model#Active>';
  $grandchild_query = 'select $object from <#ri> where (walk(
        $object <fedora-rels-ext:isMemberOfCollection> <info:fedora/' . $object->id . '> and
        $object <fedora-rels-ext:isMemberOfCollection> $parent) or walk(
        $object <fedora-rels-ext:isMemberOf> <info:fedora/' . $object->id . '> and
        $object <fedora-rels-ext:isMemberOf> $parent))
        and $object <fedora-model:state> <info:fedora/fedora-system:def/model#Active>';
  return array(
    'collectionchildren' => array(
      'type' => 'itql',
      'query' => $collection_query,
      'description' => t('All children of this collection (existing and new).'),
    ),
    'collectiongrandchildren' => array(
      'type' => 'itql',
      'query' => $grandchild_query,
      'description' => t('All children of this collection and collections within this collection (existing and new).'),
    ),
  );
}

/**
 * Implements hook_islandora_ingest_steps().
 */
function islandora_xacml_editor_islandora_ingest_steps(array $form_state) {
  // We check the parent passed through the form in the form state.
  $parent = $form_state['islandora']['shared_storage']['parent'];
  $objects = isset($form_state['islandora']['objects']) ? $form_state['islandora']['objects'] : array();
  return array(
    'islandora_xacml_policy' => array(
      'type' => 'callback',
      'weight' => 8,
      'module' => 'islandora_xacml_editor',
      'do_function' => array(
        'function' => 'islandora_xacml_editor_apply_policy',
        'args' => array($parent, $objects),
      ),
      'undo_function' => array(
        'function' => 'islandora_xacml_editor_undo_policy',
        'args' => array($objects),
      ),
    ),
  );
}

/**
 * Applies the parent's POLICY datastream to the child if it exists.
 *
 * @param array $form_state
 *   The passed through form_state from hook_islandora_ingest_steps().
 * @param string $parent
 *   PID of the parent object.
 * @param array $objects
 *   An array containing all AbstractObjects we are applying the parent's POLICY
 *   to.
 */
function islandora_xacml_editor_apply_policy(&$form_state, $parent, $objects) {
  $parent_object = islandora_object_load($parent);
  if ($parent_object['POLICY']) {
    foreach ($objects as $object) {
      $xacml = new IslandoraXacml($object, $parent_object['POLICY']->content);
      $xacml->writeBackToFedora();
    }
  }
}

/**
 * Deletes the POLICY datastream and relationships added through the apply.
 *
 * @param array $form_state
 *   The passed through form_state from hook_islandora_ingest_steps().
 * @param array $objects
 *   An array containing AbstractObjects to parse through.
 */
function islandora_xacml_editor_undo_policy(&$form_state, $objects) {
  foreach ($objects as $object) {
    if (isset($object['POLICY'])) {
      $viewable_by_user = 'isViewableByUser';
      $viewable_by_role = 'isViewableByRole';
      $object->purgeDatastream('POLICY');
      $object->relationships->remove(ISLANDORA_RELS_EXT_URI, $viewable_by_user);
      $object->relationships->remove(ISLANDORA_RELS_EXT_URI, $viewable_by_role);

      foreach ($object as $dsid => $value) {
        $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_user);
        $object[$dsid]->relationships->remove(ISLANDORA_RELS_INT_URI, $viewable_by_role);
      }
    }
  }
}

/**
 * AJAX callback to remove the selected filters from the rules table.
 */
function islandora_xacml_editor_remove_selected($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * AJAX callback to remove all filters from the rules table.
 */
function islandora_xacml_editor_remove_all($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * AJAX callback to add a DSID Regex to the rules table.
 */
function islandora_xacml_editor_add_dsid_regex_js($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * AJAX callback to add a DSID to the rules table.
 */
function islandora_xacml_editor_add_dsid_js($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * AJAX callback to add a MIME Regex to the rules table.
 */
function islandora_xacml_editor_add_mime_regex_js($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * AJAX callback to add a MIME Type to the rules table.
 */
function islandora_xacml_editor_add_mime_js($form, $form_state) {
  return $form['dsid_mime']['rules'];
}

/**
 * Callback that performs autocomplete operations.
 */
function islandora_xacml_editor_dsid_autocomplete($pid, $string) {
  $object = islandora_object_load($pid);
  $output = array();

  foreach ($object as $datastream) {
    if ($string != '*') {
      if (strpos(drupal_strtoupper($datastream->id), drupal_strtoupper($string)) !== FALSE) {
        $output[$datastream->id] = check_plain($datastream->id);
      }
    }
    else {
      $output[$datastream->id] = check_plain($datastream->id);
    }
  }
  $restricted_dsids = variable_get('islandora_xacml_editor_restricted_dsids', '');
  $restricted_dsids = preg_split('/[\s,]+/', $restricted_dsids);

  $output = array_diff($output, $restricted_dsids);

  drupal_json_output($output);
}

/**
 * Callback that performs autocomplete operations.
 */
function islandora_xacml_editor_mime_autocomplete($pid, $string) {
  module_load_include('inc', 'islandora', 'includes/utilities');

  $output = array();
  $object = islandora_object_load($pid);

  if ($object['COLLECTION_POLICY']) {
    $collection_policy = new CollectionPolicy($object['COLLECTION_POLICY']->content);
    $collection_models = array_keys($collection_policy->getContentModels());
    $mime = islandora_xacml_editor_retrieve_mimes($collection_models);
  }
  else {
    $mime = islandora_xacml_editor_retrieve_mimes($object->models);
  }
  foreach ($mime as $key => $value) {
    if ($string != "*") {
      if (strpos(drupal_strtoupper($key), drupal_strtoupper($string)) !== FALSE) {
        $output[$key] = check_plain($key);
      }
    }
    else {
      $output[$key] = check_plain($key);
    }
  }
  $restricted_mimes = variable_get('islandora_xacml_editor_restricted_mimes', '');
  $restricted_mimes = preg_split('/[\s,]+/', $restricted_mimes);

  $output = array_diff($output, $restricted_mimes);

  drupal_json_output($output);

}

/**
 * Retrieves the MIME Types from the DS-COMPOSITE for use in autocomplete.
 *
 * @param array $models
 *   An array of content models.
 *
 * @return array
 *   An array of MIME types.
 */
function islandora_xacml_editor_retrieve_mimes($models) {
  module_load_include('inc', 'islandora', 'includes/utilities');

  $mimes = array();
  $datastreams = islandora_get_datastreams_requirements_from_models($models);

  foreach ($datastreams as $key => $value) {
    foreach ($value['mime'] as $mime) {
      if (!in_array($mime, $mimes)) {
        $mimes[$mime] = $value['mime'];
      }
    }
  }
  return $mimes;
}

/**
 * Batch callback function which updates the POLICY for a target pid.
 *
 * @param XML $xml
 *   The XML content defining an XACML policy.
 * @param string $pid
 *   The PID of the object we are going to update.
 * @param array $query_array
 *   An associative array where the key is the unique ID and contains:
 *   -type: The type of query, either sparql or itql.
 *   -query: The defined query string.
 *   -description: The human-readable description of the query.
 * @param array $context
 *   Context array used in the batch.
 */
function islandora_xacml_editor_batch_function($xml, $pid, $query_array, &$context) {
  if (empty($context['sandbox'])) {
    $query = new IslandoraXacmlEditorQuery($pid, $query_array);
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['pids'] = $query->getPids();
    $context['sandbox']['items'] = count($context['sandbox']['pids']);
    $context['results']['redirect'] = $pid;
    $context['results']['success'] = array();
    $context['results']['fail'] = array();
  }
  $targetpid = array_pop($context['sandbox']['pids']);
  $context['sandbox']['progress']++;

  $policy_update = new IslandoraUpdatePolicy($targetpid, $xml);
  $success = $policy_update->updatePolicy();

  if ($success) {
    $context['results']['success'][] = $targetpid;
  }
  else {
    $context['results']['fail'][] = $targetpid;
  }

  // Make sure we don't divide by zero.
  $context['finished'] = $context['sandbox']['items'] == 0 ? 1 : $context['sandbox']['progress'] / $context['sandbox']['items'];
}

/**
 * Finished function for the update policy batch.
 *
 * @param bool $success
 *   Whether the batch was successful or not.
 * @param array $results
 *   An array containing the results of the batch operations.
 * @param array $operations
 *   The operations array that was used in the batch.
 */
function islandora_xacml_editor_batch_finished($success, $results, $operations) {
  if ($success) {
    $message = format_plural(count($results['success']), 'One policy updated.', '@count policies updated.');
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);

  if ($results['fail']) {
    foreach ($results['fail'] as $fail) {
      drupal_set_message(t("Failed to update: @failed_object. You do not have permission to update this object.", array('@failed_object' => $fail)), 'error');
    }
  }

  $pid = $results['redirect'];
  drupal_goto('islandora/object/' . $pid);
}

/**
 * Class used in the batch updating of POLICY datastreams on objects.
 */
class IslandoraUpdatePolicy {
  protected $pid;

  /**
   * Constructorsaurusrex.
   *
   * @param string $pid
   *   The pid of the object we are batching.
   * @param XML $xml
   *   The XACML XML.
   */
  public function __construct($pid, $xml) {
    // Used at a couple different points...  Let's just load this here?
    $this->pid = $pid;
    $this->xml = $xml;
    $this->object = islandora_object_load($pid);
  }

  /**
   * Updates the POLICY datastream of the object.
   *
   * @return bool
   *   The success of the operation.
   */
  public function updatePolicy() {
    global $user;
    $success = FALSE;
    if (isset($this->object)) {
      try {
        $xacml = new IslandoraXacml($this->object);
        if ($xacml->managementRule->hasPermission($user->name, $user->roles)) {
          $success = $this->addOrUpdateAllPolicies();
        }
      }
      catch (XacmlException $e) {
      }
    }
    return $success;
  }

  /**
   * Updates or adds the new POLICY datastream back to the object.
   */
  protected function addOrUpdateAllPolicies() {
    $object_policy = new IslandoraXacml($this->object, $this->xml);
    $object_policy->writeBackToFedora();
    return TRUE;
  }
}

/**
 * Class used in executing queries to Fedora.
 */
class IslandoraXacmlEditorQuery {
  protected $pid;
  protected $query;

  /**
   * Constructorsaurusrex.
   *
   * @param string $pid
   *   The PID of the object using as a base for queries.
   * @param array $query_array
   *   An associative array where the key is the unique ID and contains:
   *   -type: The type of query, either sparql or itql.
   *   -query: The defined query string.
   *   -description: The human-readable description of the query.
   */
  public function __construct($pid, $query_array) {
    $this->pid = $pid;
    $this->query = $query_array;
  }

  /**
   * Executes a defined query.
   *
   * @param array $query_array
   *   An associative array where the key is the unique ID and contains:
   *   -type: The type of query, either sparql or itql.
   *   -query: The defined query string.
   *   -description: The human-readable description of the query.
   * @param string $object_pid
   *   The pid of the object we are using as a base for queries.
   *
   * @return array
   *   An array containing the results of our query.
   */
  public static function query($query_array, $object_pid) {
    $object = islandora_object_load($object_pid);
    if ($query_array['type'] == 'itql') {
      $content = $object->repository->ri->itqlQuery($query_array['query'], 'unlimited', '0');
    }
    else {
      $content = $object->repository->ri->sparqlQuery($query_array['query'], 'unlimited', '0');
    }
    return $content;
  }

  /**
   * Helper function that retrieves all results of our query.
   * @return array
   *   An array of the PIDs returned from the defiend query.
   */
  public function getPids() {
    $pids = array();
    $query_results = IslandoraXacmlEditorQuery::query($this->query, $this->pid);

    foreach ($query_results as $result) {
      $pid = $result['object']['value'];
      $pids[] = $pid;
    }
    return $pids;
  }
}
